module memory

import "stdlib/c.cxy" as C
import { HashSet } from "stdlib/map.cxy"

pub native type max_align_t;

#const MIN_MEM_BLOCK_CAPACITY = 1024
#const MAX_ANONYMOUS_PREFIX_SIZE = 256

@poco
struct MemPoolStats {
    totalAllocated: u64 = 0
    totalUsed: u64 = 0
    numberOfBlocks: u64 = 0
}

@poco
struct MemBlock {
    size: u64
    capacity: u64
    next: This
    @alignas(size: "max_align_t") data: [char, 0]

    func remaining() {
        assert!(capacity >= size);
        return capacity - size;
    }
}

pub class MemPool {
    - first: &MemBlock
    - cur: &MemBlock

    - func allocBlock(capacity: u64, prev: &MemBlock = null) {
        if (capacity < #{MIN_MEM_BLOCK_CAPACITY})
            capacity = #{MIN_MEM_BLOCK_CAPACITY}
        var block = C.malloc(sizeof!(#MemBlock) + capacity) !: &MemBlock;
        block.capacity = capacity
        block.size = 0
        block.next = null
        if (prev != null)
            prev.next = block
        return block
    }

    - func aligned(size: u64, alignment: u64) {
        var offset = size % alignment;
        return offset != 0 ? size + alignment - offset : size
    }

    func allocate(size: u64): &void {
        if (size == 0)
            return null
        size = aligned(size, sizeof!(#max_align_t))
        if (cur == null) {
           first = cur = allocBlock(size);
        }
        else {
            // Try to re-use the next memory pools if they are appropriately sized
            while (cur.remaining() < size) {
                if (cur.next == null) {
                    cur = allocBlock(size, cur)
                    break
                }
                cur = cur.next
                assert!(cur.size == 0)
            }
        }
        assert!(cur.remaining() >= size)

        var ptr = ((<&char>cur.data) + cur.size) : &void;
        cur.size += size
        return ptr
    }

    func reset() {
        var block = first;
        while (block != null) {
            block.size = 0
            block = block.next
        }
        cur = first
    }

    const func stats() {
        var stats = MemPoolStats{};
        var block = first;
        while (block != null) {
            stats.numberOfBlocks++
            stats.totalAllocated += block.capacity
            stats.totalUsed += block.size
            block = block.next
        }

        return stats
    }

    @inline
    func alloc[T]() => allocate(sizeof!(#T)) !: T

    func `init`() {
    }

    func `deinit`() {
        var block = first;
        while (block != null) {
            var next = block.next;
            C.free(block !: &void)
            block = next
        }
        first = null
        cur = null
    }

    const func `hash`() => 0
    const func `str`(sb: StringBuilder) => {}
}

pub struct InternedString {
    - s: string
    - count: u64

    func `init`(s: string) {
        this.s = s
        count = strlen(s: &const char)
    }

    func `init`(s: string, count: u64) {
        this.s = s
        this.count = count
    }

    func `init`(s: String) {
        this.s = s.str
        count = s.count
    }

    @inline
    func `==`(other: This) => this.s == other.s
    @inline
    func `==`(s: string) => this.s == s
    @inline
    func `!=`(other: This) => this.s != other.s
    @inline
    func `!=`(s: string) => this.s != s
    @inline
    const func `hash`() => hashPointer(hashInit(), s: &void)
    @inline
    const func `str`(sb: StringBuilder) { sb.appendString(s) }
    @inline
    func toString() => String(this.s, this.count)
}

pub class StringPool {
    interned: HashSet[String]
    pool:  MemPool

    func `init`(pool: MemPool) {
        this.pool = pool
        this.interned = HashSet[String]()
    }

    func intern(str: String) {
        var found = interned.get(str);
        if (found) {
            return InternedString(*found)
        }
        var buff = pool.allocate(str.count + 1): &char;
        memcpy(buff, str.str : &void, str.count)
        buff.[str.count] = <char>'\0'
        interned.insert(String(buff: string, str.count))
        return InternedString(buff: string, str.count)
    }

    func intern(str: InternedString) => intern(str.toString())

    func concat(str: String, ...other: String) {
        var buf: [char, #{MAX_ANONYMOUS_PREFIX_SIZE + 32}];
        memcpy(buf, str.str: &void, str.count)
        var size = str.count;
        #for (const i: 0..other.membersCount) {
            memcpy(&buf.[size], other.#{i}.str: &void, other.#{i}.count)
            size += other.#{i}.count
        }
        return intern(String(buf: string, size))

    }
}
