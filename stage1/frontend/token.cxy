module token

import { FilePos } from "../core/log.cxy"

@builtins(get_name: toString)
enum TokId {
    LParen,
    RParen,
    LBracket,
    RBracket,
    LBrace,
    RBrace,
    At,
    Hash,
    LNot,
    BNot,
    Dot,
    DotDot,
    Elipsis,
    Question,
    Comma,
    Colon,
    Semicolon,
    Assign,
    Equal,
    NotEqual,
    FatArrow,
    ThinArrow,
    Less,
    LessEqual,
    Shl,
    ShlEqual,
    Greater,
    GreaterEqual,
    Shr,
    ShrEqual,
    Plus,
    Minus,
    Mult,
    Div,
    Mod,
    BAnd,
    BXor,
    BOr,
    LAnd,
    LOr,
    PlusPlus,
    MinusMinus,
    PlusEqual,
    MinusEqual,
    MultEqual,
    DivEqual,
    ModEqual,
    BAndEqual,
    BXorEqual,
    BOrEqual,
    Quote,
    Substitute,
    IndexExpr,
    CallOverride,
    IndexOverride,
    IndexAssignOvd,
    AstMacroAccess,
    Define,
    BangColon,
    /* Keywords */
    Auto,
    _kwBegin = Auto,
    True,
    False,
    Null,
    If,
    Else,
    Match,
    For,
    In,
    While,
    Break,
    Return,
    Continue,
    Func,
    Var,
    Const,
    Type,
    Native,
    Struct,
    Enum,
    Pub,
    Opaque,
    Async,
    Await,
    Switch,
    Case,
    Default,
    Defer,
    Macro,
    Void,
    String,
    Range,
    Module,
    Import,
    CDefine,
    CInclude,
    CSources,
    As,
    From,
    Unsafe,
    Interface,
    This_,
    ThisClass,
    Super,
    Class,
    /* Primitive type tokens */
    U8,
    _typBegin = U8,
    U16,
    U32,
    U64,
    I8,
    I16,
    I32,
    I64,
    F32,
    F64,
    Bool,
    Char,
    CChar,
    _tpEnd = CChar,
    _kwEnd = CChar,
    /* Other tokens */
    Ident,
    IntLiteral,
    FloatLiteral,
    CharLiteral,
    StringLiteral,
    LString,
    RString,
    LStrFmt,
    EoF,
    Error,
    COUNT
}

pub func toString(tok: TokId) {
    switch (tok) {
        case .LParen => return "("
        case .RParen => return ")"
        case .LBracket => return "["
        case .RBracket => return "]"
        case .LBrace => return "{"
        case .RBrace => return "}"
        case .At => return   "@"
        case .Hash => return "#"
        case .LNot => return "!"
        case .BNot => return "~"
        case .Dot => return "."
        case .DotDot => return ".."
        case .Elipsis => return "..."
        case .Question => return "?"
        case .Comma => return ","
        case .Colon => return ":"
        case .Semicolon => return ";"
        case .Assign => return "="
        case .Equal => return "=="
        case .NotEqual => return "!="
        case .FatArrow => return "=>"
        case .ThinArrow => return "->"
        case .Less => return "<"
        case .LessEqual => return "<="
        case .Shl => return "<<"
        case .ShlEqual => return "<<="
        case .Greater => return ">"
        case .GreaterEqual => return ">="
        case .Shr => return ">>"
        case .ShrEqual => return ">>="
        case .Plus => return "+"
        case .Minus => return "-"
        case .Mult => return "*"
        case .Div => return "/"
        case .Mod => return "%"
        case .BAnd => return "&"
        case .BXor => return "^"
        case .BOr => return "|"
        case .LAnd => return "&&"
        case .LOr => return "||"
        case .PlusPlus => return "++"
        case .MinusMinus => return "--"
        case .PlusEqual => return "+="
        case .MinusEqual => return "-="
        case .MultEqual => return "*="
        case .DivEqual => return "/="
        case .ModEqual => return "%="
        case .BAndEqual => return "&="
        case .BXorEqual => return "^="
        case .BOrEqual => return "|="
        case .Quote => return "`"
        case .Substitute => return "#{"
        case .IndexExpr => return ".["
        case .CallOverride => return "()"
        case .IndexOverride => return "[]"
        case .IndexAssignOvd => return "[]="
        case .AstMacroAccess => return  "#."
        case .Define => return "##"
        case .BangColon => return "!:"
        case .Auto => "auto"
        case .True => "true"
        case .False => "false"
        case .Null =>  "null"
        case .If => "if"
        case .Else => "else"
        case .Match => "match"
        case .For => "for"
        case .In => "in"
        case .While => "while"
        case .Break => "break"
        case .Return => "return"
        case .Continue => "continue"
        case .Func => "func"
        case .Var => "var"
        case .Const => "const"
        case .Type => "type"
        case .Native => "native"
        case .Struct => "struct"
        case .Enum => "enum"
        case .Pub => "pub"
        case .Opaque => "opaque"
        case .Async =>  "async"
        case .Await =>  "await"
        case .Switch => "switch"
        case .Case => "case"
        case .Default => "default"
        case .Defer => "defer"
        case .Macro => "macro"
        case .Void => "void"
        case .String => "string"
        case .Range =>  "range"
        case .Module => "module"
        case .Import => "import"
        case .CDefine => "cDefine"
        case .CInclude => "cInclude"
        case .As =>      "as"
        case .From =>    "from"
        case .Unsafe =>  "unsafe"
        case .Interface => "interface"
        case .This_ =>      "this"
        case .ThisClass =>  "This"
        case .Super =>     "super"
        case .Class =>     "class",
        case .U8 => "u8",
        case .U16 => "u16"
        case .U32 => "u32"
        case .U64 => "u64"
        case .I8 => "i8"
        case .I16 => "i16"
        case .I32 => "i32"
        case .I64 => "i64"
        case .F32 => "f32"
        case .F64 => "f64"
        case .Bool => "bool"
        case .Char => "wchar"
        case .CChar => "char"
        case .Ident => "identifier"
        case .IntLiteral => "integer literal"
        case .FloatLiteral => "floating-point literal"
        case .CharLiteral => "character literal"
        case .StringLiteral => "string literal"
        case .LString => "`("
        case .RString => ")`"
        case .LStrFmt => "${"
        case .EoF => "end of file"
        case .Error => "invalid token"
        default => "<unknown>"
    }
}

@poco
pub struct Token {
    tag: TokId;
    value: i64 | f64 | wchar
    fileLoc: FileLoc

    func `init`(loc: FileLoc, tag: TokId) {
        this.fileLoc = loc
        this.tag = tag
    }

    func `init`(loc: FileLoc, value: i64) {
        this.value = value
        this.tag = .IntLiteral
        this.fileLoc = loc
    }

    func `init`(loc: FileLoc, value: f64) {
        this.value = value
        this.tag = .FloatLiteral
        this.fileLoc = loc
    }

    func `init`(value: wchar) {
        this.value = value
        this.tag = .CharLiteral
    }
}