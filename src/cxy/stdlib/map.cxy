module map

const DEFAULT_HASH_TABLE_CAPACITY = 4;
const OCCUPIED_MASK  = 0x80000000 : u32;
const MAX_LOAD_FACTOR = 70; // %

@inline
func incrementWrap(capacity: u64, index: u64) => (index + 1 >= capacity) ? (<u64>0) : index + 1;

@inline
func isOccupiedHash(hash: u32) => (hash & OCCUPIED_MASK) == OCCUPIED_MASK;

@builtins(toString: false)
struct HashMapNode[K, V] {
    key: K
    value: V

    func `new`() {}
}

pub struct HashMap[K, V] {
    - data: [HashMapNode[K, V]]
    - hashes: [u32]
    - size: u64 = 0

    @inline
    - func needsRehash() => size * 100 >= len!(data) * MAX_LOAD_FACTOR

    @inline
    - func isBucketOccupied(bucket: u64) => isOccupiedHash(hashes.[bucket])

    - func rehash() {
        var newCapacity = CXY__hash_next_prime(len!(data));
        if (newCapacity <= len!(data))
            newCapacity = len!(data) * 2 + 1;
        var newData = allocSlice[HashMapNode[K,V]](newCapacity);
        var newHashes = allocSlice[u32](newCapacity);

        var n = len!(data);
        for (const i: 0..n) {
            const hashCode = hashes.[i];
            if (!isOccupiedHash(hashCode))
                continue;
            var index = CXY__hash_mod_prime(<u64>hashCode, newCapacity);
            while (isOccupiedHash(newHashes.[index]))
                index = incrementWrap(newCapacity, index);

            newData.[index] = data.[i]
            data.[i] = HashMapNode[K, V]();
            newHashes.[index] = hashCode;
        }

        delete hashes
        delete data
        hashes = newHashes;
        data = newData
    }

    @inline
    - func removeAt(key: K, index: u64) {
        var removed: V? = data.[index].value;

        var next = incrementWrap(len!(data), index);
        while (isBucketOccupied(next)) {
            const nextHash = hashes.[next];
            const desired = CXY__hash_mod_prime(nextHash, len!(data));
            if (desired <= index || desired > next) {
                data.[index] = data.[next]
                hashes.[index] = nextHash
               index = next
            }
            next = incrementWrap(len!(data), next)
        }
        hashes.[index] = 0
        size--

        return removed
    }

    func `new`(capacity: u64 = DEFAULT_HASH_TABLE_CAPACITY) {
        capacity = CXY__hash_next_prime(capacity)
        hashes = allocSlice[u32](capacity)
        data = allocSlice[HashMapNode[K, V]](capacity)
    }

    func insert(key: K, value: V, replace: bool = true) {
        var hashCode = hash[K](key) | OCCUPIED_MASK;
        var index = CXY__hash_mod_prime(hashCode, len!(data));
        while (isBucketOccupied(index)) {
            if (hashes.[index] == hashCode && key == data.[index].key){
                if (replace)
                    data.[index].value = value
                return false;
            }
            index = incrementWrap(len!(data), index)
        }

        data.[index] = HashMapNode[K, V]{key: key, value: value}
        hashes.[index] = hashCode
        size++

        if (needsRehash())
            rehash()

        return true;
    }

    func get(key: K) : V? {
        const hashCode = hash[K](key) | OCCUPIED_MASK;
        var index = CXY__hash_mod_prime(hashCode, len!(data));
        while (isBucketOccupied(index)) {
            if (hashes.[index] == hashCode && key == data.[index].key)
                return data.[index].value;
            index = incrementWrap(len!(data), index)
        }
        return null
    }

    func remove(key: K) : V? {
        const hashCode = hash[K](key) | OCCUPIED_MASK;
        var index = CXY__hash_mod_prime(hashCode, len!(data));
        var found = false;
        while (isBucketOccupied(index)) {
            if (hashes.[index] == hashCode && key == data.[index].key) {
                return removeAt(key, index)
            }
            index = incrementWrap(len!(data), index)
        }

        return null
    }

    func clear() {
        if (size == 0)
            return;

        for (const i : 0..len!(data)) {
            if (isBucketOccupied(i))
                delete &data.[i]
        }

        CXY__builtins_memset_slice(#[u32], hashes, 0)
        size = 0
    }

    @inline
    func `[]`(key: K) => get(key)

    @inline
    func `[]=`(key: K, value: V) => insert(key, value)

    func `..`() {
        var i = 0;
        return () : (&const K, &V)? => {
            while (i < len!(data)) {
                if (isOccupiedHash(hashes.[i]))
                    return (&data.[i].key, &data.[i].value)
                i++
            }
            return null
        }
    }

    const func `..`() {
        var i = 0;
        return () : (&const K, &const V)? => {
            while (i < len!(data)) {
                if (isOccupiedHash(hashes.[i]))
                    return (&data.[i].key, &data.[i].value)
                i++
            }
            return null
        }
    }

    func toString(sb: &StringBuilder) {
        sb << "{"
        var i = 0;
        var first = true;

        while (i < len!(data)) {
            if (isOccupiedHash(hashes.[i])) {
                if (!first)
                    sb << ", "

                sb << data.[i].key << ": " << data.[i].value
                first = false
            }

            i++
        }

        sb <<  "}"
    }
}
