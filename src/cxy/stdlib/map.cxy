module map

import { Vector } from "stdlib/vector.cxy"

#const DEFAULT_HASH_TABLE_CAPACITY = 4
#const OCCUPIED_MASK  = <u32> 0x80000000
#const MAX_LOAD_FACTOR = 70 // %
#const MIN_PRIME = <u64> 7
#const MAX_PRIME = <u64> 1048583
#const NUM_PRIMES = 15

const HASH_PRIMES = [
    #{MIN_PRIME},
    17, 31, 67, 257, 1031, 4093, 8191, 16381,
    32381, 65539, 131071, 262147, 524287,
    #{MAX_PRIME}
];

pub func hashNextPrime(i: u64) {
    var j, k = (0, #{NUM_PRIMES});
    while (j < k) {
        var m = (j + k) / 2;
        var p = HASH_PRIMES.[m];
        if (p <= i)
            j = m + 1
        else
            k = m
    }
    return HASH_PRIMES.[k >= #{NUM_PRIMES} ? #{NUM_PRIMES - 1} : k];
}

@inline
pub func hashModPrime(i: u64, p: u64) => i % p

@inline
pub func incrementWrap(capacity: u64, index: u64) =>(index + 1 >= capacity) ? (<u64>0) : index + 1

@inline
pub func isOccupiedHash(hash: u32) => (hash & #{OCCUPIED_MASK}) == #{OCCUPIED_MASK};

@poco
struct HashMapNode[K, V] {
    key: K
    #if (#V != #void) {
        value: V
    }

    func `init`() {}

    @inline
    func `==`(key: K) {
        #if (K.isStruct || K.isClass) {
            return this.key == &key
        }
        else {
            return this.key == key
        }
    }
}

pub class HashMap[K, V] {
    - data: &HashMapNode[K, V]
    - hashes: &u32
    - size: u64 = 0;
    - capacity: u64 = 0;

    @inline
    - func needsRehash() => size * 100 >= capacity * #{MAX_LOAD_FACTOR}

    @inline
    - func isBucketOccupied(bucket: u64) => isOccupiedHash(hashes.[bucket])

    - func rehash() {
        var newCapacity = hashNextPrime(capacity);
        if (newCapacity <= capacity)
            newCapacity = capacity * 2 + 1;
        var newData = <&HashMapNode[K,V]> __cxy_calloc(sizeof!(#HashMapNode[K,V]) * newCapacity);
        var newHashes = <&u32> __cxy_calloc(sizeof!(#u32) * newCapacity);

        var n = capacity;
        for (const i: 0..n) {
            const hashCode = hashes.[i];
            if (!isOccupiedHash(hashCode))
                continue;
            var index = hashModPrime(<u64>hashCode, newCapacity);
            while (isOccupiedHash(newHashes.[index]))
                index = incrementWrap(newCapacity, index);

            newData.[index] = data.[i]
            //data.[i] = null
            newHashes.[index] = hashCode;
        }

        __cxy_free(hashes: &void)
        __cxy_free(data: &void)
        hashes = newHashes;
        data = newData
        capacity = newCapacity
    }

    @inline
    - func removeAt(key: K, index: u64) {
        var removed: V? = data.[index].value;

        var next = incrementWrap(capacity, index);
        while (isBucketOccupied(next)) {
            const nextHash = hashes.[next];
            const desired = hashModPrime(nextHash, capacity);
            if (desired <= index || desired > next) {
                data.[index] = data.[next]
                hashes.[index] = nextHash
               index = next
            }
            next = incrementWrap(capacity, next)
        }
        hashes.[index] = 0
        size--

        return removed
    }

    func `init`(capacity: u64 = #{DEFAULT_HASH_TABLE_CAPACITY}) {
        capacity = hashNextPrime(capacity)
        data = <&HashMapNode[K,V]> __cxy_calloc(sizeof!(#HashMapNode[K,V]) * capacity)
        hashes = <&u32> __cxy_calloc(sizeof!(#u32) * capacity)
        this.capacity = capacity
    }

    func `deinit`() {
        if (capacity) {
            for (const i : 0..capacity) {
                if (isBucketOccupied(i)) {
                    //data.[i] = null
                }
            }

            __cxy_free(data: &void)
            __cxy_free(hashes: &void)
            size = 0
            capacity = 0
        }
    }

    func insert(key: K, value: V, replace: bool = true) {
        var hashCode = hash[K](key) | #{OCCUPIED_MASK};
        var index = hashModPrime(hashCode, capacity);
        while (isBucketOccupied(index)) {
            if (hashes.[index] == hashCode && data.[index] == key){
                if (replace)
                    data.[index].value = value
                return false;
            }
            index = incrementWrap(capacity, index)
        }

        data.[index] = HashMapNode[K, V]{key: key, value: value}
        hashes.[index] = hashCode
        size++

        if (needsRehash()) {
            rehash()
        }

        return true;
    }

    func get(key: K) : V? {
        const hashCode = hash[K](key) | #{OCCUPIED_MASK};
        var index = hashModPrime(hashCode, capacity);
        while (isBucketOccupied(index)) {
            if (hashes.[index] == hashCode && data.[index] == key)
                return data.[index].value;
            index = incrementWrap(capacity, index)
        }
        return null
    }

    func remove(key: K) : V? {
        const hashCode = hash[K](key) | #{OCCUPIED_MASK};
        var index = hashModPrime(hashCode, capacity);
        var found = false;
        while (isBucketOccupied(index)) {
            if (hashes.[index] == hashCode && data.[index] == key) {
                return removeAt(key, index)
            }
            index = incrementWrap(capacity, index)
        }

        return null
    }

    func clear() {
        if (size == 0)
            return;

        for (const i : 0..capacity) {
            if (isBucketOccupied(i)) {
                //data.[i] = null
            }
        }

        memset(hashes: &void, 0, sizeof!(#u32)*capacity)
        size = 0
    }

    @inline
    func `[]`(key: K) => get(key)

    @inline
    func `[]=`(key: K, value: V) => insert(key, value)

    func `..`() {
        var i = 0;
        return () : (K, V)? => {
            while (i < capacity) {
                if (isOccupiedHash(hashes.[i]))
                    return (data.[i].key, data.[i++].value)
                i++
            }
            return null
        }
    }

    func each(fun: func(key: K, value: V) -> void) {
        var i = 0;
        while (i < capacity) {
            if (isOccupiedHash(hashes.[i]))
                fun(data.[i].key, data.[i].value)
            i++
        }
    }

    func map[U](transform: func(key: K, value: V) -> U) {
        var output = Vector[U]();
        this.each((key: K, value: V) => { output.push(transform(key, value)) })
        return output
    }

    const func `str`(sb: String) {
        sb << "{"
        var i = 0;
        var first = true;

        while (i < capacity) {
            if (isOccupiedHash(hashes.[i])) {
                if (!first)
                    sb << ", "

                sb << data.[i].key << ": " << data.[i].value
                first = false
            }

            i++
        }

        sb <<  "}"
    }
}

pub class HashSet[K] {
    - data: &HashMapNode[K, void]
    - hashes: &u32
    - size: u64 = 0;
    - capacity: u64 = 0;

    @inline
    - func needsRehash() => size * 100 >= capacity * #{MAX_LOAD_FACTOR}

    @inline
    - func isBucketOccupied(bucket: u64) => isOccupiedHash(hashes.[bucket])

    - func rehash() {
        var newCapacity = hashNextPrime(capacity);
        if (newCapacity <= capacity)
            newCapacity = capacity * 2 + 1;
        var newData = <&HashMapNode[K, void]> __cxy_calloc(sizeof!(#HashMapNode[K, void]) * newCapacity);
        var newHashes = <&u32> __cxy_calloc(sizeof!(#u32) * newCapacity);

        var n = capacity;
        for (const i: 0..n) {
            const hashCode = hashes.[i];
            if (!isOccupiedHash(hashCode))
                continue;
            var index = hashModPrime(<u64>hashCode, newCapacity);
            while (isOccupiedHash(newHashes.[index]))
                index = incrementWrap(newCapacity, index);

            newData.[index] = data.[i]
            newHashes.[index] = hashCode;
        }

        __cxy_free(hashes: &void)
        __cxy_free(data: &void)
        hashes = newHashes;
        data = newData
        capacity = newCapacity
    }

    @inline
    - func removeAt(key: K, index: u64) {
        var next = incrementWrap(capacity, index);
        while (isBucketOccupied(next)) {
            const nextHash = hashes.[next];
            const desired = hashModPrime(nextHash, capacity);
            if (desired <= index || desired > next) {
                data.[index] = data.[next]
                hashes.[index] = nextHash
               index = next
            }
            next = incrementWrap(capacity, next)
        }
        hashes.[index] = 0
        size--
    }

    func `init`(capacity: u64 = #{DEFAULT_HASH_TABLE_CAPACITY}) {
        capacity = hashNextPrime(capacity)
        data = <&HashMapNode[K, void]> __cxy_calloc(sizeof!(#HashMapNode[K, void]) * capacity)
        hashes = <&u32> __cxy_calloc(sizeof!(#u32) * capacity)
        this.capacity = capacity
    }

    func `deinit`() {
        if (capacity) {
            for (const i : 0..capacity) {
                if (isBucketOccupied(i)) {
                    //data.[i] = null
                }
            }

            __cxy_free(data: &void)
            __cxy_free(hashes: &void)
            size = 0
            capacity = 0
        }
    }

    func insert(key: K) {
        var hashCode = hash[K](key) | #{OCCUPIED_MASK};
        var index = hashModPrime(hashCode, capacity);
        while (isBucketOccupied(index)) {
            if (hashes.[index] == hashCode && data.[index] == key) {
                return false
            }
            index = incrementWrap(capacity, index)
        }
        data.[index] = HashMapNode[K, void]{key: key}
        hashes.[index] = hashCode
        size++

        if (needsRehash())
            rehash()

        return true;
    }

    func get(key: K) : K? {
        const hashCode = hash[K](key) | #{OCCUPIED_MASK};
        var index = hashModPrime(hashCode, capacity);
        while (isBucketOccupied(index)) {
            if (hashes.[index] == hashCode && data.[index] == key)
                return data.[index].key
            index = incrementWrap(capacity, index)
        }
        return null
    }

    func contains(key: K) => !!get(key)

    func remove(key: K) {
        const hashCode = hash[K](key) | #{OCCUPIED_MASK};
        var index = hashModPrime(hashCode, capacity);
        var found = false;
        while (isBucketOccupied(index)) {
            if (hashes.[index] == hashCode && data.[index] == key) {
                removeAt(key, index)
                return true
            }
            index = incrementWrap(capacity, index)
        }

        return false
    }

    func each(fun: func(key: K) -> void) {
        var i = 0;
        while (i < capacity) {
            if (isOccupiedHash(hashes.[i]))
                fun(data.[i].key)
            i++
        }
    }

    func map[U](transform: func(key: K) -> U) {
        var output = Vector[U]();
        this.each((key: K) => { output.push(transform(key)) })
        return output
    }

    func clear() {
        if (size == 0)
            return;

        for (const i : 0..capacity) {
            if (isBucketOccupied(i)) {
                //data.[i] = null
            }
        }

        memset(hashes: &void, 0, sizeof!(#u32)*capacity)
        size = 0
    }

    func `..`() {
        var i = 0;
        return () : K? => {
            while (i < capacity) {
                if (isOccupiedHash(hashes.[i]))
                    return data.[i++].key
                i++
            }
            return null
        }
    }

    const func `str`(sb: String) {
        sb << "{"
        var i = 0;
        var first = true;

        while (i < capacity) {
            if (isOccupiedHash(hashes.[i])) {
                if (!first)
                    sb << ", "

                sb << data.[i].key
                first = false
            }

            i++
        }

        sb <<  "}"
    }
}