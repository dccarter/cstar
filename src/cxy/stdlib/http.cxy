module http

import { TcpSocket } from "./tcp.cxy"
import { HashMap } from "./hash.cxy"

import "_ctype.h" as ctype
import "stdlib.h" as stdlib
import "strings.h" as cstrings

import "native/http/parser.h" as parser

pub enum Method {
    Delete,
    Get,
    Head,
    Post,
    Put,
    Connect,
    Options,
    Trace,
    Unknown
}

enum Status : i32 {
    CONTINUE			        = 100,
    SWITCHING_PROTOCOLS		    = 101,
    OK				            = 200,
    CREATED			            = 201,
    ACCEPTED			        = 202,
    NON_AUTHORITATIVE		    = 203,
    NO_CONTENT			        = 204,
    RESET_CONTENT		        = 205,
    PARTIAL_CONTENT		        = 206,
    MULTIPLE_CHOICES		    = 300,
    MOVED_PERMANENTLY		    = 301,
    FOUND			            = 302,
    SEE_OTHER			        = 303,
    NOT_MODIFIED		        = 304,
    USE_PROXY			        = 305,
    TEMPORARY_REDIRECT		    = 307,
    BAD_REQUEST			        = 400,
    UNAUTHORIZED		        = 401,
    PAYMENT_REQUIRED		    = 402,
    FORBIDDEN			        = 403,
    NOT_FOUND			        = 404,
    METHOD_NOT_ALLOWED		    = 405,
    NOT_ACCEPTABLE		        = 406,
    PROXY_AUTH_REQUIRED		    = 407,
    REQUEST_TIMEOUT		        = 408,
    CONFLICT			        = 409,
    GONE			            = 410,
    LENGTH_REQUIRED		        = 411,
    PRECONDITION_FAILED		    = 412,
    REQUEST_ENTITY_TOO_LARGE	= 413,
    REQUEST_URI_TOO_LARGE	    = 414,
    UNSUPPORTED_MEDIA_TYPE	    = 415,
    REQUEST_RANGE_INVALID	    = 416,
    EXPECTATION_FAILED		    = 417,
    INTERNAL_ERROR		        = 500,
    NOT_IMPLEMENTED		        = 501,
    BAD_GATEWAY			        = 502,
    SERVICE_UNAVAILABLE	    	= 503,
    GATEWAY_TIMEOUT		        = 504,
    BAD_VERSION			        = 505
}

@inline
func toupper(c: wchar) => <char>(<u32>ctype.toupper(<i32>c))

pub func methodFromString(method: string) {
    var x = toupper(method.[0]);
    switch(x) {
        case 'D':char => return Method.Delete
        case 'G':char => return Method.Get
        case 'H':char => return Method.Head
        case 'P':char => {
            if (toupper(method.[1]) == 'O':char)
                return Method.Post
            else
                return Method.Put
        }
        case 'C':char => return Method.Connect
        case 'O':char => return Method.Options
        case 'T':char => return Method.Trace
        default  => return Method.Unknown
    }
}

pub func statusText(status: Status) {
    var r: string;
    switch (status) {
        case .CONTINUE =>
            return "HTTP/1.1 100 Continue"
        case .SWITCHING_PROTOCOLS =>
            return "HTTP/1.1 101 Switching Protocols"
        case .OK =>
            return "HTTP/1.1 200 OK"
        case .CREATED =>
            return "HTTP/1.1 201 Created"
        case .ACCEPTED =>
            return "HTTP/1.1 202 Accepted"
        case .NON_AUTHORITATIVE =>
            return "HTTP/1.1 203 Non-Authoritative Information"
        case .NO_CONTENT =>
            return "HTTP/1.1 204 No Content"
        case .RESET_CONTENT =>
            return "HTTP/1.1 205 Reset Content"
        case .PARTIAL_CONTENT =>
            return "HTTP/1.1 206 Partial Content"
        case .MULTIPLE_CHOICES =>
            return "HTTP/1.1 300 Multiple Choices"
        case .MOVED_PERMANENTLY =>
            return "HTTP/1.1 301 Moved Permanently"
        case .FOUND =>
            return "HTTP/1.1 302 Found"
        case .SEE_OTHER =>
            return "HTTP/1.1 303 See Other"
        case .NOT_MODIFIED =>
            return "HTTP/1.1 304 Not Modified"
        case .USE_PROXY =>
            return "HTTP/1.1 305 Use Proxy"
        case .TEMPORARY_REDIRECT =>
            return "HTTP/1.1 307 Temporary Redirect"
        case .BAD_REQUEST =>
            return "HTTP/1.1 400 Bad Request"
        case .UNAUTHORIZED =>
            return "HTTP/1.1 401 Unauthorized"
        case .PAYMENT_REQUIRED =>
            return "HTTP/1.1 402 Payment Required"
        case .FORBIDDEN =>
            return "HTTP/1.1 403 Forbidden"
        case .NOT_FOUND =>
            return "HTTP/1.1 404 Not Found"
        case .METHOD_NOT_ALLOWED =>
            return "HTTP/1.1 405 Method Not Allowed"
        case .NOT_ACCEPTABLE =>
            return "HTTP/1.1 406 Not Acceptable"
        case .PROXY_AUTH_REQUIRED =>
            return "HTTP/1.1 407 Proxy Authentication Required"
        case .REQUEST_TIMEOUT =>
            return "HTTP/1.1 408 Request Time-out"
        case .CONFLICT =>
            return "HTTP/1.1 409 Conflict"
        case .GONE =>
            return "HTTP/1.1 410 Gone"
        case .LENGTH_REQUIRED =>
            return "HTTP/1.1 411 Length Required"
        case .PRECONDITION_FAILED =>
            return "HTTP/1.1 412 Precondition Failed"
        case .REQUEST_ENTITY_TOO_LARGE =>
            return "HTTP/1.1 413 Request Entity Too Large"
        case .REQUEST_URI_TOO_LARGE =>
            return "HTTP/1.1 414 Request-URI Too Large"
        case .UNSUPPORTED_MEDIA_TYPE =>
            return "HTTP/1.1 415 Unsupported Media Type"
        case .REQUEST_RANGE_INVALID =>
            return "HTTP/1.1 416 Requested range not satisfiable"
        case .EXPECTATION_FAILED =>
            return "HTTP/1.1 417 Expectation Failed"
        case .INTERNAL_ERROR =>
            return "HTTP/1.1 500 Internal Server Error"
        case .NOT_IMPLEMENTED =>
            return "HTTP/1.1 501 Not Implemented"
        case .BAD_GATEWAY =>
            return "HTTP/1.1 502 Bad Gateway"
        case .SERVICE_UNAVAILABLE =>
            return "HTTP/1.1 503 Service Unavailable"
        case .GATEWAY_TIMEOUT =>
            return "HTTP/1.1 504 Gateway Time-out"
        case .BAD_VERSION =>
            return "HTTP/1.1 505 HTTP Version not supported"
        default =>
            return "HTTP/1.1 500  "
    }
}

pub func methodName(method: Method) {
    switch(method) {
        case .Delete =>
            return "DELETE"
        case .Get =>
            return "GET"
        case .Head =>
            return "HEAD"
        case .Post =>
            return "POST"
        case .Put =>
            return "PUT"
        case .Connect =>
            return "CONNECT"
        case .Options =>
            return "OPTIONS"
        case .Trace =>
            return "TRACE"
        default =>
            return "Invalid"
    }
}

pub var CONTENT_LENGTH = CString("Content-Length");

pub class Request {
    - sock: TcpSocket
    - headers = HashMap[String, String, HashCase, EqualsCase]();
    - method: Method = .Unknown;
    - path: String
    - body: String
    - minorVersion: i32
    - contentLength: u64

    func `init`(sock: TcpSocket) {
        this.sock = sock
    }

    func parseHeaders(buf: &const char, len: u64) {
        var method: &const char = null;
        var methodLen : u64 = 0;
        var path: &const char = null;
        var pathLen : u64 = 0;
        var headers: [parser.phr_header, 128];
        var numHeaders: u64 = len!(headers);
        var minorVersion: i32 = -1;

        var parsed = parser.phr_parse_request(
            buf,
            len,
            &method,
            &methodLen,
            &path,
            &pathLen,
            &minorVersion,
            &headers !: &parser.phr_header,
            &numHeaders,
            len);

        if (parsed < 0) {
            // failed to parse request
            return Status.BAD_REQUEST
        }

        this.method = methodFromString(method !: string)
        this.minorVersion = minorVersion
        this.path = String(path, pathLen)
        for (var i: 0..numHeaders) {
            const header = headers.[i];
            const headerName = CString(header.name !: string, header.name_len);
            if (headerName == CONTENT_LENGTH) {
                //var s = CString(header.value !: string, header.value_len);
                this.contentLength =
                    CString(header.value !: string, header.value_len).toi[u64]();
            }
            else {
                this.headers.[String(header.name, header.name_len)] =
                    String(header.value, header.value_len)
            }
        }
    }
}