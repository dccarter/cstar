module vector

#const DEFAULT_VECTOR_CAPACITY = <u64>16

pub class Vector[T] {
    - data: &T
    - count: u64
    - capacity: u64

    - func grow() {
        if (count >= capacity) {
            capacity += (capacity / 2)
            data = <&T> __cxy_realloc(data: &void, sizeof!(#T) * capacity)
        }
    }

    func `init`(initialSize: u64 = #{DEFAULT_VECTOR_CAPACITY}) {
        capacity = initialSize
        data = <&T> __cxy_alloc(sizeof!(#T) * capacity)
    }

    @inline
    func `deinit`() {
        #if (T.isDestructible) {
            for (const i: 0..count) {
                data.[i] = null
            }
        }
        __cxy_free(data: &void)
    }

    func push(item: T) {
        grow()
        data.[count++] = item
    }

    func pop() {
        assert!(count > 0)
        count--
        return data.[count]
    }

    func shift() {
        assert!(count > 0)
        var item = data.[0];
        var tmp = data;
        count--
        memmove(tmp, ptroff!(tmp + 1), sizeof!(#T) * count)
        return item
    }

    func resize(newSize: u64) {
        data = <&T> __cxy_realloc(data: &void, sizeof!(#T) * newSize)
        if (newSize < count)
            count = newSize
       capacity = newSize;
    }

    @inline
    func shrink() {
        resize(count)
    }

    func `[]`(index: i32) {
        assert!(index < count)
        return data.[index]
    }

    func `[]=`(index: i32, value: T) {
        assert!(index < count)
        data.[index] = value
    }

    func `..`() {
        var i : i64 = 0;
        return () : (T, i64)? => {
            if (i < count)
                return (data.[i], i++)
            else
                return null
        }
    }

    func each(cb: func(item: T) -> void) {
        for (var i: 0..count) {
            cb(data.[i])
        }
    }

    func accumulate[U](fun: func(acc: U, item: T) -> U, acc: U) {
        for (var i: 0..count) {
            acc = fun(acc, data.[i])
        }
        return acc
    }

    func filter(fun: func(item: T) -> bool) {
        var vec = Vector[T]();
        for (var i: 0..count) {
            if (fun(data.[i]))
                vec.push(data.[i])
        }
        return vec
    }

    func map[U](fun: func(item: T) -> U) {
        var vec = Vector[U]();
        for (var i: 0..count) {
            vec.push(fun(data.[i]))
        }
        return vec
    }

    func find(predicate: func(elem: T)->bool) : T? {
        for (var i: 0..count) {
            if (predicate(data.[i]))
                return data.[i]
        }
        return null
    }

    const func `str`(sb: String) {
        sb << '['
        for (var i: 0..count) {
            if (i != 0)
                sb << ", "
            sb << data.[i]
        }
        sb << ']'
    }
}
