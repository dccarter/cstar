/**
 * Builtin cxy functions, types and constants
 */

// Unix Error Codes
 ##pub (
    errno,
    EPERM,
    ENOENT,
    ESRCH,
    EINTR,
    EIO,
    ENXIO,
    E2BIG,
    ENOEXEC,
    EBADF,
    ECHILD,
    EAGAIN,
    ENOMEM,
    EACCES,
    EFAULT,
    ENOTBLK,
    EBUSY,
    EEXIST,
    EXDEV,
    ENODEV,
    ENOTDIR,
    EISDIR,
    EINVAL,
    ENFILE,
    EMFILE,
    ENOTTY,
    ETXTBSY,
    EFBIG,
    ENOSPC,
    ESPIPE,
    EROFS,
    EMLINK,
    EPIPE,
    EDOM,
    ERANGE,
    ENOMSG,
    EIDRM,
    ECHRNG,
    EL2NSYNC,
    EL3HLT,
    EL3RST,
    ELNRNG,
    EUNATCH,
    ENOCSI,
    EL2HLT,
    EDEADLK,
    ENOLCK,
    EBADE,
    EBADR,
    EXFULL,
    ENOANO,
    EBADRQC,
    EBADSLT,
    EDEADLOCK,
    EBFONT,
    ENOSTR,
    ENODATA,
    ETIME,
    ENOSR,
    ENONET,
    ENOPKG,
    EREMOTE,
    ENOLINK,
    EADV,
    ESRMNT,
    ECOMM,
    EPROTO,
    EMULTIHOP,
    ELBIN,
    EDOTDOT,
    EBADMSG,
    EFTYPE,
    ENOTUNIQ,
    EBADFD,
    EREMCHG,
    ELIBACC,
    ELIBBAD,
    ELIBSCN,
    ELIBMAX,
    ELIBEXEC,
    ENOSYS,
    ENMFILE,
    ENOTEMPTY,
    ENAMETOOLONG,
    ELOOP,
    EOPNOTSUPP,
    EPFNOSUPPORT,
    ECONNRESET,
    ENOBUFS,
    EAFNOSUPPORT,
    EPROTOTYPE,
    ENOTSOCK,
    ENOPROTOOPT,
    ESHUTDOWN,
    ECONNREFUSED,
    EADDRINUSE,
    ECONNABORTED,
    ENETUNREACH,
    ENETDOWN,
    ETIMEDOUT,
    EHOSTDOWN,
    EHOSTUNREACH,
    EINPROGRESS,
    EALREADY,
    EDESTADDRREQ,
    EMSGSIZE,
    EPROTONOSUPPORT,
    ESOCKTNOSUPPORT,
    EADDRNOTAVAIL,
    ENETRESET,
    EISCONN,
    ENOTCONN,
    ETOOMANYREFS,
    EPROCLIM,
    EUSERS,
    EDQUOT,
    ESTALE,
    ENOTSUP,
    ENOMEDIUM,
    ENOSHARE,
    ECASECLASH,
    EILSEQ,
    EOVERFLOW,
 ) : i32

## pub (
    memcpy,
    memmove
) : func(dst: &void, src: &const void, len: u64) -> &void

## pub (
    memset
) : func(dst: &void, ch: i32, len: u64) -> &void


## pub (
    CXY__builtins_sizeof
) : func(typ: auto) -> u64

## pub (
    CXY__alloc
) : func(size: u64, dctor: func(ptr: &const void) -> void) -> &void

## pub (
    CXY__realloc
) : func(ptr: &void, size: u64, dctor: func(ptr: &const void) -> void) -> &void

## pub (
    CXY__free
) : func(ptr: &void) -> void

@inline
pub func newClass[T]() => CXY__alloc(sizeof!(#T), null) : T

## pub(
    strlen
): func(str: &const char) -> u64

type HashCode = u32

## pub(hashInit => CXY__hash_fnv1a_init):  func() -> u32

## pub (
    hashPointer => CXY__hash_fnv1a_ptr
): func(init: HashCode, ptr: &const void) -> u32

## pub(
    hashUint8 => CXY__hash_fnv1a_uint8
): func(init: HashCode, val: u8) -> u32

## pub(
    hashUint16 => CXY__hash_fnv1a_uint16
): func(init: HashCode, val: u16) -> u32

## pub(
    hashUint32 => CXY__hash_fnv1a_uint32
): func(init: HashCode, val: u32) -> u32

## pub(
    hashUint64 => CXY__hash_fnv1a_uint64
): func(init: HashCode, val: u64) -> u32

## pub(
    hashBytes => CXY__hash_fnv1a_bytes
): func(init: HashCode, str: &const void, size: u64) -> u32

## pub(
    CXY__hash_fnv1a_string
): func(init: HashCode, str: &const char) -> u32

@inline
pub func hashString(
    init: HashCode,
    str: string
) => CXY__hash_fnv1a_string(init, str !: &const char)

@inline
pub func hashStringSize(
    init: HashCode,
    str: string,
    len: u64
) => hashBytes(init, str !: &const char, len)

pub func hash[T](val: T, init: HashCode = 0) {
    #if (#T == #string) {
        return hashString(hashInit(), val)
    }
    else #if (#T == #i8 || #T == #u8) {
        return hashUint8(hashInit(), <u8>val)
    }
    else #if (#T == #i16 || #T == #u16) {
        return hashUint16(hashInit(), <u16>val)
    }
    else #if (#T == #i32 || #T == #u32) {
        return hashUint32(hashInit(), <u32>val)
    }
    else #if (#T == #i64 || #T == #u64) {
        return hashUint64(hashInit(), <u64>val)
    }
    else {
        // this will fail if T does not implement hash function
        return val.op__hash()
    }
}

pub native func CXY__hash_next_prime(i: u64) : u64;
pub native func CXY__hash_mod_prime(i: u64, p: u64) : u64;

pub native type CXY__builtins_string_builder_t;

pub native func CXY__builtins_string_builder_new(): CXY__builtins_string_builder_t;

pub native func CXY__builtins_string_builder_delete(
    self: CXY__builtins_string_builder_t
) : void;

pub native func CXY__builtins_string_builder_release(
    self: CXY__builtins_string_builder_t
) : &char;

pub native func CXY__builtins_string_builder_append_cstr0(
    self: CXY__builtins_string_builder_t,
    str:  &const char,
    len:  u64
) : void;

pub native func CXY__builtins_string_builder_append_cstr1(
    self: CXY__builtins_string_builder_t,
    str:  &const char,
) : void;

pub native func CXY__builtins_string_builder_append_int(
    self: CXY__builtins_string_builder_t,
    num: i64
) : void;

pub native func CXY__builtins_string_builder_append_float(
    self: CXY__builtins_string_builder_t,
    num: f64
) : void;

pub native func CXY__builtins_string_builder_append_char(
    self: CXY__builtins_string_builder_t,
    ch: wchar
): void;

pub native func CXY__builtins_string_builder_append_bool(
    self: CXY__builtins_string_builder_t,
    val: bool
): void;

pub native func CXY__builtins_string_builder_append_ptr(
    self: CXY__builtins_string_builder_t,
    val: &const void
): void;

pub native func CXY__builtins_get_ref(ptr: &void): void;
pub native func CXY__builtins_drop(ptr: &void): void;

@inline
pub func getref[T](obj: T) {
    CXY__builtins_get_ref(obj: &void)
    return obj
}

@inline
pub func dropref[T](obj: T) => CXY__free(obj: &void)

class StringBuilder {
    - sb: CXY__builtins_string_builder_t

    @inline
    func `init`() : void {  sb = CXY__builtins_string_builder_new() }

    @inline
    func `deinit`() => CXY__builtins_string_builder_delete(sb)

    @inline
    func appendString(str: string) =>
        CXY__builtins_string_builder_append_cstr1(sb, str !: &const char)

    @inline
    func appendInt(num: i64) =>
        CXY__builtins_string_builder_append_int(sb, num)

    @inline
    func appendFloat(num: f64) =>
        CXY__builtins_string_builder_append_float(sb, num)

    @inline
    func appendChar(ch: wchar) =>
        CXY__builtins_string_builder_append_char(sb, ch)


    @inline
    func appendBool(val: bool) =>
        CXY__builtins_string_builder_append_bool(sb, val)

    func appendPointer[T](ptr: &const T) =>
        CXY__builtins_string_builder_append_ptr(sb, ptr: &const void)

    @inline
    func `<<`[U](val: U) : StringBuilder {
        #if (U.isString)
            appendString(val)
        else #if (U.isInteger)
            appendInt(<i64>val)
        else #if (U.isFloat)
            appendFloat(val)
        else #if (U.isBoolean)
            appendBool(val)
        else #if (#U == #wchar)
             appendChar(val)
        else #if (U.isEnum)
            appendInt(<i64>val)
        else #if (U.isStruct || U.isClass)
            val.op__str(this)
        else #if (U.isTuple) {
            this.appendChar('(')
            #for (const i: 0..U.membersCount) {
                #if (i != 0)
                    this.appendString(", ")
                this << val.#{i}
            }
            this.appendChar(')')
        }
        else #if (U.isArray || U.isSlice) {
            this.appendChar('[')
            for (const i: 0..len!(val)) {
                if (i != 0)
                    this.appendString(", ")
                this << val.[i]
            }
            this.appendChar(']')
        }
        return this
    }

    func `str`(sb: StringBuilder) {
        appendPointer[void](sb: &const void)
    }

    @inline
    const func `hash`() => hashPointer(hashInit(), this: &const void)

    @inline
    func release() {
        return CXY__builtins_string_builder_release(sb) : string
    }
}

/**
 * Builtin optional type
 *
 * Corresponds to type T?
 */
struct Optional[T] {
    - valid: bool = false;
    - value: T

    /* Creates an invalid optional type */
    @inline
    func `init`() { valid = false }

    /* Creates a valid optional type */
    @inline
    func `init`(value: T) {
        this.value = value
        valid = true
    }

    /* Checks whether an optional is valid or not */
    @inline
    const func `!!`() => valid

    @inline
    const func read() {
        assert!(valid)
        return value
    }

    const func `str`(sb: StringBuilder) {
        if (valid)
            sb << value
        else
            sb << "null"
    }

    const func `hash`() => hash(this)
}

/* Creates a valid optional value */
@inline
func Some[T](value: T) => Optional[T](value)

/* Creates an invalid optional value */
@inline
func None[T]() => Optional[T]()

@inline
func structToString[T](it: &const T, sb: StringBuilder) {
    sb << #{T.name} << '{'
    #const i = 0;
    #for (const member: T.members) {
        #if (member.isField) {
            #if (i != 0) {
                sb << ", "
            }

            sb << #{member.name} << ": " << it.#{mkIdent!(member.name)}
            #{i += 1}
        }
    }
    sb << '}'
}

@inline
func computeStructHash[T](it: &const T) {
    var code = hashInit();
    #for (const member: T.members) {
        #if (member.isField) {
            code = hash[#{member.Tinfo}](it.#{mkIdent!(member.name)}, code)
        }
    }
    return code
}

@inline
func classToString[T](it: const T, sb: StringBuilder) {
    sb << "<" << #{T.name} << ":"
    sb.appendPointer[void](it: &const void)
    sb << '>'
}

@inline
func computeClassHash[T](it: const T) {
    return hashPointer(hashInit(), it : &void)
}
