/**
 * Builtin cxy functions, types and constants
 */

// Unix Error Codes
 ##pub (
    errno,
    EPERM,
    ENOENT,
    ESRCH,
    EINTR,
    EIO,
    ENXIO,
    E2BIG,
    ENOEXEC,
    EBADF,
    ECHILD,
    EAGAIN,
    ENOMEM,
    EACCES,
    EFAULT,
    ENOTBLK,
    EBUSY,
    EEXIST,
    EXDEV,
    ENODEV,
    ENOTDIR,
    EISDIR,
    EINVAL,
    ENFILE,
    EMFILE,
    ENOTTY,
    ETXTBSY,
    EFBIG,
    ENOSPC,
    ESPIPE,
    EROFS,
    EMLINK,
    EPIPE,
    EDOM,
    ERANGE,
    ENOMSG,
    EIDRM,
    ECHRNG,
    EL2NSYNC,
    EL3HLT,
    EL3RST,
    ELNRNG,
    EUNATCH,
    ENOCSI,
    EL2HLT,
    EDEADLK,
    ENOLCK,
    EBADE,
    EBADR,
    EXFULL,
    ENOANO,
    EBADRQC,
    EBADSLT,
    EDEADLOCK,
    EBFONT,
    ENOSTR,
    ENODATA,
    ETIME,
    ENOSR,
    ENONET,
    ENOPKG,
    EREMOTE,
    ENOLINK,
    EADV,
    ESRMNT,
    ECOMM,
    EPROTO,
    EMULTIHOP,
    ELBIN,
    EDOTDOT,
    EBADMSG,
    EFTYPE,
    ENOTUNIQ,
    EBADFD,
    EREMCHG,
    ELIBACC,
    ELIBBAD,
    ELIBSCN,
    ELIBMAX,
    ELIBEXEC,
    ENOSYS,
    ENMFILE,
    ENOTEMPTY,
    ENAMETOOLONG,
    ELOOP,
    EOPNOTSUPP,
    EPFNOSUPPORT,
    ECONNRESET,
    ENOBUFS,
    EAFNOSUPPORT,
    EPROTOTYPE,
    ENOTSOCK,
    ENOPROTOOPT,
    ESHUTDOWN,
    ECONNREFUSED,
    EADDRINUSE,
    ECONNABORTED,
    ENETUNREACH,
    ENETDOWN,
    ETIMEDOUT,
    EHOSTDOWN,
    EHOSTUNREACH,
    EINPROGRESS,
    EALREADY,
    EDESTADDRREQ,
    EMSGSIZE,
    EPROTONOSUPPORT,
    ESOCKTNOSUPPORT,
    EADDRNOTAVAIL,
    ENETRESET,
    EISCONN,
    ENOTCONN,
    ETOOMANYREFS,
    EPROCLIM,
    EUSERS,
    EDQUOT,
    ESTALE,
    ENOTSUP,
    ENOMEDIUM,
    ENOSHARE,
    ECASECLASH,
    EILSEQ,
    EOVERFLOW,
    EWOULDBLOCK,
 ) : i32

## pub (
    memcpy,
    memmove
) : func(dst: &void, src: &const void, len: u64) -> &void

## pub (
    memset
) : func(dst: &void, ch: i32, len: u64) -> &void

## pub (
    free
) : func(ptr: &void) -> void


## pub (
    CXY__builtins_sizeof
) : func(typ: auto) -> u64

## pub (
    CXY__builtins_assert
) : func(cond: bool, file: string, line: u64, pos: u64) -> void

## pub (
    CXY__alloc
) : func(size: u64, dctor: func(ptr: &const void) -> void) -> &void

## pub (
    CXY__realloc
) : func(ptr: &void, size: u64, dctor: func(ptr: &const void) -> void) -> &void

## pub (
    CXY__free
) : func(ptr: &void) -> void

@inline
pub func newClass[T]() => CXY__alloc(sizeof!(#T), T.op__destructor_fwd) : T

## pub(
    strlen
): func(str: &const char) -> u64

## pub(
    strcmp
): func(s1: &const char, s2: &const char) -> i32

## pub(
    CXY__itoa
): func(value: i32, str: &char) -> i32

type HashCode = u32

## pub(hashInit => CXY__hash_fnv1a_init):  func() -> u32

## pub (
    hashPointer => CXY__hash_fnv1a_ptr
): func(init: HashCode, ptr: &const void) -> u32

## pub(
    hashUint8 => CXY__hash_fnv1a_uint8
): func(init: HashCode, val: u8) -> u32

## pub(
    hashUint16 => CXY__hash_fnv1a_uint16
): func(init: HashCode, val: u16) -> u32

## pub(
    hashUint32 => CXY__hash_fnv1a_uint32
): func(init: HashCode, val: u32) -> u32

## pub(
    hashUint64 => CXY__hash_fnv1a_uint64
): func(init: HashCode, val: u64) -> u32

## pub(
    hashBytes => CXY__hash_fnv1a_bytes
): func(init: HashCode, str: &const void, size: u64) -> u32

## pub(
    CXY__hash_fnv1a_string
): func(init: HashCode, str: &const char) -> u32

@inline
pub func hashString(
    init: HashCode,
    str: string
) => CXY__hash_fnv1a_string(init, str !: &const char)

@inline
pub func hashStringSize(
    init: HashCode,
    str: string,
    len: u64
) => hashBytes(init, str !: &const char, len)

pub func hash[T](val: const T, init: HashCode = 0) : HashCode {
    #if (#T == #string) {
        return hashString(hashInit(), val)
    }
    else #if (#T == #i8 || #T == #u8) {
        return hashUint8(hashInit(), <u8>val)
    }
    else #if (#T == #i16 || #T == #u16) {
        return hashUint16(hashInit(), <u16>val)
    }
    else #if (#T == #i32 || #T == #u32) {
        return hashUint32(hashInit(), <u32>val)
    }
    else #if (T.isFloat || #T == #i64 || #T == #u64) {
        return hashUint64(hashInit(), <u64>val)
    }
    else #if (T.isEnum) {
        return hashUint64(hashInit(), <u64>val)
    }
    else #if (T.isTuple) {
        var code = hashInit();
        #for (const i: 0..T.membersCount) {
            code = hash(val.#{i}, code)
        }
        return code
    }
    else #if (T.isArray || T.isSlice) {
        var code = hashInit();
        for (const x: val) {
            code = hash(x, code)
        }
        return code
    }
    else {
        // this will fail if T does not implement hash function
        return val.op__hash()
    }
}

pub native func CXY__hash_next_prime(i: u64) : u64;
pub native func CXY__hash_mod_prime(i: u64, p: u64) : u64;

pub native type CXY__builtins_string_builder_t;

pub native func CXY__builtins_string_builder_new(): CXY__builtins_string_builder_t;

pub native func CXY__builtins_string_builder_delete(
    self: CXY__builtins_string_builder_t
) : void;

pub native func CXY__builtins_string_builder_release(
    self: CXY__builtins_string_builder_t
) : &char;

pub native func CXY__builtins_string_builder_size(
    self: CXY__builtins_string_builder_t
) : u64;

pub native func CXY__builtins_string_builder_append_cstr0(
    self: CXY__builtins_string_builder_t,
    str:  &const char,
    len:  u64
) : void;

pub native func CXY__builtins_string_builder_append_cstr1(
    self: CXY__builtins_string_builder_t,
    str:  &const char,
) : void;

pub native func CXY__builtins_string_builder_append_int(
    self: CXY__builtins_string_builder_t,
    num: i64
) : void;

pub native func CXY__builtins_string_builder_append_float(
    self: CXY__builtins_string_builder_t,
    num: f64
) : void;

pub native func CXY__builtins_string_builder_append_char(
    self: CXY__builtins_string_builder_t,
    ch: wchar
): void;

pub native func CXY__builtins_string_builder_append_bool(
    self: CXY__builtins_string_builder_t,
    val: bool
): void;

pub native func CXY__builtins_string_builder_append_ptr(
    self: CXY__builtins_string_builder_t,
    val: &const void
): void;

pub native func CXY__builtins_get_ref(ptr: &void): void;
pub native func CXY__builtins_drop(ptr: &void): void;

## (
    fdWaitIn => CXY__eventloop_wait_read,
    fdWaitOut => CXY__eventloop_wait_write
): func(fd: i32, timeout: i64) -> i32

## (
    fdClear => CXY__eventloop_fd_clear
): func(fd: i32, mask: i32) -> i32

## (
    EV_OK => AE_OK,
    EV_IN => AE_READABLE,
    EV_OUT => AE_WRITABLE
) : i32

@inline
pub func getref[T](@transient obj: T) {
    CXY__builtins_get_ref(obj: &void)
    return obj
}

@inline
pub func dropref[T](@transient obj: T) => CXY__free(obj: &void)

pub struct String {
    - str: string
    - count: u64

    func `init`(str: string) {
        this.str = str
        count = strlen(str: &const char)
    }

    func `init`(str: string, count: u64) {
        this.str = str
        this.count = count
    }

    @inline
    func `deref`() => str

    @inline
    func `deinit`() {
        CXY__free(this.str : &void)
        str = null
        count = 0
    }

    @inline
    func `hash`() => hashString(hashInit(), str)

    @inline
    func `copy`() => String{str: getref(str), count: count}

    @[pure]
    func `destructor_fwd`(ptr: &void) {
        (<&String>ptr).op__deinit()
    }
}

class StringBuilder {
    - sb: CXY__builtins_string_builder_t

    @inline
    func `init`() : void {  sb = CXY__builtins_string_builder_new() }

    @inline
    func `deinit`() => CXY__builtins_string_builder_delete(sb)

    @[pure]
    func `destructor_fwd`(ptr: &void) {
        (<StringBuilder>ptr).op__deinit()
    }

    @inline
    func appendString(str: string) =>
        CXY__builtins_string_builder_append_cstr1(sb, str !: &const char)

    @inline
    func appendString(str: String) =>
        CXY__builtins_string_builder_append_cstr1(sb, str.str !: &const char)

    @inline
    func appendInt(num: i64) =>
        CXY__builtins_string_builder_append_int(sb, num)

    @inline
    func appendFloat(num: f64) =>
        CXY__builtins_string_builder_append_float(sb, num)

    @inline
    func appendChar(ch: wchar) =>
        CXY__builtins_string_builder_append_char(sb, ch)


    @inline
    func appendBool(val: bool) =>
        CXY__builtins_string_builder_append_bool(sb, val)

    func appendPointer[T](ptr: &const T) =>
        CXY__builtins_string_builder_append_ptr(sb, ptr: &const void)

    @inline
    func `<<`[U](val: const U) : StringBuilder {
        #if (U.isString)
            appendString(val)
        else #if (U.isInteger)
            appendInt(<i64>val)
        else #if (U.isFloat)
            appendFloat(val)
        else #if (U.isBoolean)
            appendBool(val)
        else #if (#U == #wchar)
             appendChar(val)
        else #if (U.isEnum)
            appendInt(<i64>val)
        else #if (U.isStruct || U.isClass)
            val.op__str(this)
        else #if (U.isTuple) {
            this.appendChar('(')
            #for (const i: 0..U.membersCount) {
                #if (i != 0)
                    this.appendString(", ")
                this << val.#{i}
            }
            this.appendChar(')')
        }
        else #if (U.isArray || U.isSlice) {
            this.appendChar('[')
            for (const i: 0..len!(val)) {
                if (i != 0)
                    this.appendString(", ")
                this << val.[i]
            }
            this.appendChar(']')
        }
        return this
    }

    func `str`(sb: StringBuilder) {
        appendPointer[void](sb: &const void)
    }

    @inline
    const func `hash`() => hashPointer(hashInit(), this: &const void)

    @inline
    func release() {
        const count = CXY__builtins_string_builder_size(sb);
        return String(
            CXY__builtins_string_builder_release(sb) : string,
            count)
    }
}

/**
 * Builtin optional type
 *
 * Corresponds to type T?
 */
struct Optional[T] {
    - valid: bool = false;
    - value: T

    /* Creates an invalid optional type */
    @inline
    func `init`() { valid = false }

    /* Creates a valid optional type */
    @inline
    func `init`(value: T) {
        this.value = value
        valid = true
    }

    /* Checks whether an optional is valid or not */
    @inline
    const func `!!`() => valid

    @inline
    const func `deref`() {
        assert!(valid)
        return value
    }

    const func `str`(sb: StringBuilder) {
        if (valid)
            sb << value
        else
            sb << "null"
    }

    const func `hash`() {
        if (this.valid)
            return hash(this.value)
        return hashInit()
    }
}

/* Creates a valid optional value */
@inline
func Some[T](@transient value: T) => Optional[T](value)

/* Creates an invalid optional value */
@inline
func None[T]() => Optional[T]()

pub struct Slice[T] {
    - data: &T
    - count: u64

    func `init`(data: &T, count: u64) {
        this.data = data
        this.count = count
    }

    @inline
    func `[]=`(index:  i64, data: T) {
        CXY__builtins_assert(index < count, file!, line!, column!)
        this.data.[index] = data
    }

    @inline
    func `[]`(index:  i64) {
        CXY__builtins_assert(index < count, file!, line!, column!)
        return this.data.[index]
    }

    @inline
    const func `[]`(index:  i64) {
        CXY__builtins_assert(index < count, file!, line!, column!)
        return this.data.[index]
    }

    const func `..`() {
        var i = 0;
        return () : (T, i)? => {
            if (i < count)
                return (data.[i], i++)
            return null
        }
    }

    const func `hash`() : HashCode {
        var code = hashInit();
        for (const i: 0..count) {
            code = hash(data.[i], code)
        }
        return code
    }

    const func `str`(sb: StringBuilder) {
        sb.appendChar('[')
        for (const i: 0..count) {
            if (i != 0)
                sb.appendString(", ")
            sb << data.[i]
        }
        sb.appendChar(']')
    }
}

@inline
func structToString[T](it: &const T, sb: StringBuilder) {
    sb << #{T.name} << '{'
    #const i = 0;
    #for (const member: T.members) {
        #if (member.isField) {
            #if (i != 0) {
                sb << ", "
            }

            sb << #{member.name} << ": " << it.#{mkIdent!(member.name)}
            #{i += 1}
        }
    }
    sb << '}'
}

@inline
func computeStructHash[T](it: &const T) {
    var code = hashInit();
    #for (const member: T.members) {
        #if (member.isField) {
            code = hash[#{member.Tinfo}](it.#{mkIdent!(member.name)}, code)
        }
    }
    return code
}

@inline
func classToString[T](it: const T, sb: StringBuilder) {
    sb << "<" << #{T.name} << ":"
    sb.appendPointer[void](it: &const void)
    sb << '>'
}

@inline
func computeClassHash[T](it: const T) {
    return hashPointer(hashInit(), it : &void)
}

@inline
func destructorForward[T](ptr: &void)
{
    #if (T.strippedType.isStruct)
        (<&T>ptr).op__destructor()
    else
        (<T>ptr).op__destructor()
}

## pub (
    CXY_DEFAULT_CORO_STACK_SIZE
) : u64

## pub(
    now => CXY__now_ms
): func() -> i64

## pub(
    msleep => CXY__eventloop_sleep
): func(ms: i64) -> void

@alias(name: "Coro")
pub native type tina;

## pub(
    suspendCoroutine => CXY__scheduler_suspend
): func() -> void

## pub (
    scheduleCoroutine => CXY__scheduler_schedule
): func(co: Coro) -> void

## pub (
    runningCoroutineHandle => tina_running
): func() -> Coro


## pub (
    CXY__launch_coro
) : func(entry: func(args: &void) -> void, args: &void, dbg: &const char, ss: u64) -> void

pub enum PromiseState {
    Pending,
    Rejected,
    Resolved
}

pub class Promise[Ret] {
    - state: PromiseState = PromiseState.Pending;
    - pendingCoro: Coro = null

    func `init`() {
        state = PromiseState.Pending
        pendingCoro = null
    }

    #if (#Ret != #void) {
        - result: Ret
    }

    @inline
    - func resumePending() {
        if (pendingCoro != null) {
            scheduleCoroutine(pendingCoro)
        }
    }

    func reject() {
        state = PromiseState.Rejected
        resumePending()
    }

    #if (#Ret == #void) {
        func resolve() {
            state = PromiseState.Resolved
            resumePending()
        }
    }
    else {
        func resolve(res: Ret) {
            this.result = res
            state = PromiseState.Resolved
            resumePending()
        }
    }

    @inline
    - func waitPending() {
        if (state == PromiseState.Pending) {
            pendingCoro = runningCoroutineHandle()
            suspendCoroutine()
            pendingCoro = null
        }
    }

    #if (#Ret == #void) {
        func `await`() {
            waitPending()
        }
    }
    else {
        func `await`() {
            waitPending()
            return this.result
        }
    }

    const func `hash`() => 0
}

pub class Coroutine[Ret, Obj, Args] {
    args: Args
    promise: Promise[Ret]
    #if (#Obj == #void) {
        func `init`(args: Args) {
            this.args = args
            promise = Promise[Ret]()
        }
    }
    else {
        obj: Obj
        func `init`(obj: Obj, args: Args) {
            this.args = args
            this.obj = obj
            promise = Promise[Ret]()
        }
    }

    @inline
    func `hash`() => 0

    @inline
    func getPromise() => getref(promise)
}

@pure
func asyncLaunch[Ret, Args](entry: func(arg: &void) -> void, name: string,args: Args) {
    var coro = Coroutine[Ret, void, Args](args);
    var promise = coro.getPromise();
    CXY__launch_coro(entry, getref(coro): &void, name: &const char, CXY_DEFAULT_CORO_STACK_SIZE)
    return getref(promise)
}

@pure
func asyncLaunchMember[Ret, Obj, Args](entry: func(arg: &void) -> void, obj: Obj, name: string,args: Args) {
    var coro = Coroutine[Ret, Obj, Args](obj, args);
    var promise = coro.getPromise();
    CXY__launch_coro(entry, getref(coro): &void, name: &const char, CXY_DEFAULT_CORO_STACK_SIZE)
    return getref(promise)
}
